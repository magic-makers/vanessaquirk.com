'use strict';

const http = require('http');
const HttpStatus = require('http-status-codes');
const fetch = require('node-fetch');

const opengraphClient = require('opengraph-io')({
  appId: 'b64092df-ae93-4da3-a4fa-d18480e07113',
});

const contentful = require('contentful-management').createClient({
  accessToken: 'CFPAT-yk9gQpPpaBt8izqjDnOzKe5qVFsmv5Z8kvTRbototj0',
});

let _contentfulClient;
async function getContentfulClient() {
  if (_contentfulClient === undefined) {
    const space = await contentful.getSpace('sruqohogh9hk');
    _contentfulClient = await space.getEnvironment('master');
  }
  return _contentfulClient;
}

/**
 * secret tokens so that we don't process input from randos
 * tokens were randomly generated by this command
 * python3 -c "import secrets; print(secrets.token_urlsafe())
 */
const SECRET_TOKENS = new Set([
  '6vJCmBxjFwz0iJJ09WzQSDTuFAml16bIA5fJsLq5Go4', // contentful webhook
]);

// Docs on event and context https://www.netlify.com/docs/functions/#the-handler-method
exports.handler = async (event, context) => {
  try {
    if (!SECRET_TOKENS.has(event.headers.authorization)) {
      return Resp(HttpStatus.FORBIDDEN);
    }

    // const postBody = getMockContentfulPostBody();
    const postBody = JSON.parse(event.body);
    const articleUrl = postBody.fields.url['en-US'];

    const siteInfo = await getSiteInfo(articleUrl);

    const [htmlAsset, articleLink] = await Promise.allSettled([
      createAssetFromUrl(siteInfo.hybridGraph.title, articleUrl),
      saveArticleLink(siteInfo),
    ]);
    if (htmlAsset.status === 'rejected') {
      console.warn('Failed to save raw html as asset:', htmlAsset.reason);
    }
    if (articleLink.status === 'rejected') {
      throw Error(articleLink.reason);
    }
    return Resp(HttpStatus.OK, `Successfully processed url ${articleUrl}`);
  } catch (err) {
    console.error(err);
    return Resp(HttpStatus.INTERNAL_SERVER_ERROR, err.toString());
  }
};

function Resp(statusCode, body) {
  if (body == null) {
    body = http.STATUS_CODES[statusCode];
  }
  return { statusCode, body };
}

async function saveArticleLink(siteInfo) {
  const client = await getContentfulClient();
  const articleLinkContentType = await client.getContentType('articleLink');
  const articleLink = await client.createEntry(articleLinkContentType.sys.id, {
    fields: localifyFields({
      ...(await marshallFields(
        siteInfo.hybridGraph,
        articleLinkContentType.fields
      )),
      openGraphIoResponse: siteInfo,
    }),
  });
  return articleLink;
}

/**
 * Format fields from srcObj into format required by contenful fieldList
 * For now, this means creating asset Links and ensuring dates are of Date type
 */
async function marshallFields(srcObj, fieldList) {
  let destObj = {};
  for (const field of fieldList) {
    const key = field.id;
    let val = srcObj[key];
    if (val === undefined) {
      // field doesn't exist on object, skip ahead
      continue;
    }
    if (field.type === 'Link' && field.linkType === 'Asset') {
      val = assetLink(await createAssetFromUrl(srcObj.title + ' Image', val));
    } else if (field.type === 'Date') {
      val = new Date(val);
    }
    destObj[key] = val;
  }
  return destObj;
}

/**
 * replaces each field with an object like {'en-US': val}
 */
function localifyFields(srcObj, locale) {
  locale = locale || 'en-US';
  let destObj = {};
  for (const key of Object.keys(srcObj)) {
    newVal = {};
    newVal[locale] = srcObj[key];
    destObj[key] = newVal;
  }
  return destObj;
}

function assetLink(asset) {
  return {
    sys: {
      type: 'Link',
      linkType: 'Asset',
      id: asset.sys.id,
    },
  };
}

async function createAssetFromUrl(title, url) {
  const client = await getContentfulClient();
  const assetHeaders = (await fetch(url, { method: 'HEAD' })).headers;
  const asset = await client.createAsset({
    fields: localifyFields({
      title,
      file: {
        contentType: assetHeaders.get('content-type'),
        fileName: getFilenameFromUrl(url),
        upload: url,
      },
    }),
  });
  await asset.processForLocale('en-US');
  return asset;
}

function getFilenameFromUrl(url) {
  // remove trailing slash if there is one
  if (url.endsWith('/')) {
    url = url.slice(0, url.length - 1);
  }
  return url.slice(url.lastIndexOf('/') + 1);
}

function getSiteInfo(url) {
  return new Promise((resolve, reject) => {
    opengraphClient.getSiteInfo(url, function(err, siteInfo) {
      if (err) {
        reject(err);
      } else {
        resolve(siteInfo);
      }
    });
  });
}

// TODO: move this function into a proper test
function getMockContentfulPostBody() {
  return {
    sys: {
      type: 'Entry',
      id: 'SFixRHDbmnFgukjfQMsHs',
      space: { sys: { type: 'Link', linkType: 'Space', id: 'sruqohogh9hk' } },
      environment: {
        sys: { id: 'master', type: 'Link', linkType: 'Environment' },
      },
      contentType: {
        sys: { type: 'Link', linkType: 'ContentType', id: 'newLink' },
      },
      revision: 1,
      createdAt: '2020-06-20T17:36:06.230Z',
      updatedAt: '2020-06-20T17:36:06.230Z',
    },
    fields: {
      url: {
        'en-US':
          'https://www.atlasobscura.com/articles/the-lowdown-on-the-lowline-the-worlds-first-underground-park',
      },
    },
  };
}
